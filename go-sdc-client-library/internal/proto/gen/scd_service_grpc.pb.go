// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: scd_service.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	SCDService_GetLatestVersion_FullMethodName  = "/com.mercor.scd.grpc.SCDService/GetLatestVersion"
	SCDService_GetVersionHistory_FullMethodName = "/com.mercor.scd.grpc.SCDService/GetVersionHistory"
	SCDService_Query_FullMethodName             = "/com.mercor.scd.grpc.SCDService/Query"
	SCDService_Update_FullMethodName            = "/com.mercor.scd.grpc.SCDService/Update"
	SCDService_BatchGet_FullMethodName          = "/com.mercor.scd.grpc.SCDService/BatchGet"
	SCDService_BatchUpdate_FullMethodName       = "/com.mercor.scd.grpc.SCDService/BatchUpdate"
)

// SCDServiceClient is the client API for SCDService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SCDServiceClient interface {
	// Common SCD operations
	GetLatestVersion(ctx context.Context, in *GetLatestVersionRequest, opts ...grpc.CallOption) (*EntityResponse, error)
	GetVersionHistory(ctx context.Context, in *GetVersionHistoryRequest, opts ...grpc.CallOption) (*EntityListResponse, error)
	Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (*EntityListResponse, error)
	Update(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*EntityResponse, error)
	BatchGet(ctx context.Context, in *BatchGetRequest, opts ...grpc.CallOption) (*BatchResponse, error)
	BatchUpdate(ctx context.Context, in *BatchUpdateRequest, opts ...grpc.CallOption) (*BatchResponse, error)
}

type sCDServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSCDServiceClient(cc grpc.ClientConnInterface) SCDServiceClient {
	return &sCDServiceClient{cc}
}

func (c *sCDServiceClient) GetLatestVersion(ctx context.Context, in *GetLatestVersionRequest, opts ...grpc.CallOption) (*EntityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EntityResponse)
	err := c.cc.Invoke(ctx, SCDService_GetLatestVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCDServiceClient) GetVersionHistory(ctx context.Context, in *GetVersionHistoryRequest, opts ...grpc.CallOption) (*EntityListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EntityListResponse)
	err := c.cc.Invoke(ctx, SCDService_GetVersionHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCDServiceClient) Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (*EntityListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EntityListResponse)
	err := c.cc.Invoke(ctx, SCDService_Query_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCDServiceClient) Update(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*EntityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EntityResponse)
	err := c.cc.Invoke(ctx, SCDService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCDServiceClient) BatchGet(ctx context.Context, in *BatchGetRequest, opts ...grpc.CallOption) (*BatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchResponse)
	err := c.cc.Invoke(ctx, SCDService_BatchGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCDServiceClient) BatchUpdate(ctx context.Context, in *BatchUpdateRequest, opts ...grpc.CallOption) (*BatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchResponse)
	err := c.cc.Invoke(ctx, SCDService_BatchUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SCDServiceServer is the server API for SCDService service.
// All implementations must embed UnimplementedSCDServiceServer
// for forward compatibility.
type SCDServiceServer interface {
	// Common SCD operations
	GetLatestVersion(context.Context, *GetLatestVersionRequest) (*EntityResponse, error)
	GetVersionHistory(context.Context, *GetVersionHistoryRequest) (*EntityListResponse, error)
	Query(context.Context, *QueryRequest) (*EntityListResponse, error)
	Update(context.Context, *UpdateRequest) (*EntityResponse, error)
	BatchGet(context.Context, *BatchGetRequest) (*BatchResponse, error)
	BatchUpdate(context.Context, *BatchUpdateRequest) (*BatchResponse, error)
	mustEmbedUnimplementedSCDServiceServer()
}

// UnimplementedSCDServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSCDServiceServer struct{}

func (UnimplementedSCDServiceServer) GetLatestVersion(context.Context, *GetLatestVersionRequest) (*EntityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLatestVersion not implemented")
}
func (UnimplementedSCDServiceServer) GetVersionHistory(context.Context, *GetVersionHistoryRequest) (*EntityListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVersionHistory not implemented")
}
func (UnimplementedSCDServiceServer) Query(context.Context, *QueryRequest) (*EntityListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Query not implemented")
}
func (UnimplementedSCDServiceServer) Update(context.Context, *UpdateRequest) (*EntityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedSCDServiceServer) BatchGet(context.Context, *BatchGetRequest) (*BatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchGet not implemented")
}
func (UnimplementedSCDServiceServer) BatchUpdate(context.Context, *BatchUpdateRequest) (*BatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchUpdate not implemented")
}
func (UnimplementedSCDServiceServer) mustEmbedUnimplementedSCDServiceServer() {}
func (UnimplementedSCDServiceServer) testEmbeddedByValue()                    {}

// UnsafeSCDServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SCDServiceServer will
// result in compilation errors.
type UnsafeSCDServiceServer interface {
	mustEmbedUnimplementedSCDServiceServer()
}

func RegisterSCDServiceServer(s grpc.ServiceRegistrar, srv SCDServiceServer) {
	// If the following call pancis, it indicates UnimplementedSCDServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SCDService_ServiceDesc, srv)
}

func _SCDService_GetLatestVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLatestVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCDServiceServer).GetLatestVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SCDService_GetLatestVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCDServiceServer).GetLatestVersion(ctx, req.(*GetLatestVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCDService_GetVersionHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVersionHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCDServiceServer).GetVersionHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SCDService_GetVersionHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCDServiceServer).GetVersionHistory(ctx, req.(*GetVersionHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCDService_Query_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCDServiceServer).Query(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SCDService_Query_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCDServiceServer).Query(ctx, req.(*QueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCDService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCDServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SCDService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCDServiceServer).Update(ctx, req.(*UpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCDService_BatchGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCDServiceServer).BatchGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SCDService_BatchGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCDServiceServer).BatchGet(ctx, req.(*BatchGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCDService_BatchUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCDServiceServer).BatchUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SCDService_BatchUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCDServiceServer).BatchUpdate(ctx, req.(*BatchUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SCDService_ServiceDesc is the grpc.ServiceDesc for SCDService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SCDService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "com.mercor.scd.grpc.SCDService",
	HandlerType: (*SCDServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetLatestVersion",
			Handler:    _SCDService_GetLatestVersion_Handler,
		},
		{
			MethodName: "GetVersionHistory",
			Handler:    _SCDService_GetVersionHistory_Handler,
		},
		{
			MethodName: "Query",
			Handler:    _SCDService_Query_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _SCDService_Update_Handler,
		},
		{
			MethodName: "BatchGet",
			Handler:    _SCDService_BatchGet_Handler,
		},
		{
			MethodName: "BatchUpdate",
			Handler:    _SCDService_BatchUpdate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "scd_service.proto",
}

const (
	JobService_GetActiveJobsForCompany_FullMethodName    = "/com.mercor.scd.grpc.JobService/GetActiveJobsForCompany"
	JobService_GetActiveJobsForContractor_FullMethodName = "/com.mercor.scd.grpc.JobService/GetActiveJobsForContractor"
	JobService_GetJobsWithRateAbove_FullMethodName       = "/com.mercor.scd.grpc.JobService/GetJobsWithRateAbove"
	JobService_UpdateStatus_FullMethodName               = "/com.mercor.scd.grpc.JobService/UpdateStatus"
	JobService_UpdateRate_FullMethodName                 = "/com.mercor.scd.grpc.JobService/UpdateRate"
)

// JobServiceClient is the client API for JobService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Entity-specific services
type JobServiceClient interface {
	GetActiveJobsForCompany(ctx context.Context, in *GetActiveJobsForCompanyRequest, opts ...grpc.CallOption) (*JobListResponse, error)
	GetActiveJobsForContractor(ctx context.Context, in *GetActiveJobsForContractorRequest, opts ...grpc.CallOption) (*JobListResponse, error)
	GetJobsWithRateAbove(ctx context.Context, in *GetJobsWithRateAboveRequest, opts ...grpc.CallOption) (*JobListResponse, error)
	UpdateStatus(ctx context.Context, in *UpdateJobStatusRequest, opts ...grpc.CallOption) (*JobResponse, error)
	UpdateRate(ctx context.Context, in *UpdateJobRateRequest, opts ...grpc.CallOption) (*JobResponse, error)
}

type jobServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewJobServiceClient(cc grpc.ClientConnInterface) JobServiceClient {
	return &jobServiceClient{cc}
}

func (c *jobServiceClient) GetActiveJobsForCompany(ctx context.Context, in *GetActiveJobsForCompanyRequest, opts ...grpc.CallOption) (*JobListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JobListResponse)
	err := c.cc.Invoke(ctx, JobService_GetActiveJobsForCompany_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) GetActiveJobsForContractor(ctx context.Context, in *GetActiveJobsForContractorRequest, opts ...grpc.CallOption) (*JobListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JobListResponse)
	err := c.cc.Invoke(ctx, JobService_GetActiveJobsForContractor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) GetJobsWithRateAbove(ctx context.Context, in *GetJobsWithRateAboveRequest, opts ...grpc.CallOption) (*JobListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JobListResponse)
	err := c.cc.Invoke(ctx, JobService_GetJobsWithRateAbove_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) UpdateStatus(ctx context.Context, in *UpdateJobStatusRequest, opts ...grpc.CallOption) (*JobResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JobResponse)
	err := c.cc.Invoke(ctx, JobService_UpdateStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) UpdateRate(ctx context.Context, in *UpdateJobRateRequest, opts ...grpc.CallOption) (*JobResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JobResponse)
	err := c.cc.Invoke(ctx, JobService_UpdateRate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// JobServiceServer is the server API for JobService service.
// All implementations must embed UnimplementedJobServiceServer
// for forward compatibility.
//
// Entity-specific services
type JobServiceServer interface {
	GetActiveJobsForCompany(context.Context, *GetActiveJobsForCompanyRequest) (*JobListResponse, error)
	GetActiveJobsForContractor(context.Context, *GetActiveJobsForContractorRequest) (*JobListResponse, error)
	GetJobsWithRateAbove(context.Context, *GetJobsWithRateAboveRequest) (*JobListResponse, error)
	UpdateStatus(context.Context, *UpdateJobStatusRequest) (*JobResponse, error)
	UpdateRate(context.Context, *UpdateJobRateRequest) (*JobResponse, error)
	mustEmbedUnimplementedJobServiceServer()
}

// UnimplementedJobServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedJobServiceServer struct{}

func (UnimplementedJobServiceServer) GetActiveJobsForCompany(context.Context, *GetActiveJobsForCompanyRequest) (*JobListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActiveJobsForCompany not implemented")
}
func (UnimplementedJobServiceServer) GetActiveJobsForContractor(context.Context, *GetActiveJobsForContractorRequest) (*JobListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActiveJobsForContractor not implemented")
}
func (UnimplementedJobServiceServer) GetJobsWithRateAbove(context.Context, *GetJobsWithRateAboveRequest) (*JobListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetJobsWithRateAbove not implemented")
}
func (UnimplementedJobServiceServer) UpdateStatus(context.Context, *UpdateJobStatusRequest) (*JobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateStatus not implemented")
}
func (UnimplementedJobServiceServer) UpdateRate(context.Context, *UpdateJobRateRequest) (*JobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRate not implemented")
}
func (UnimplementedJobServiceServer) mustEmbedUnimplementedJobServiceServer() {}
func (UnimplementedJobServiceServer) testEmbeddedByValue()                    {}

// UnsafeJobServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to JobServiceServer will
// result in compilation errors.
type UnsafeJobServiceServer interface {
	mustEmbedUnimplementedJobServiceServer()
}

func RegisterJobServiceServer(s grpc.ServiceRegistrar, srv JobServiceServer) {
	// If the following call pancis, it indicates UnimplementedJobServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&JobService_ServiceDesc, srv)
}

func _JobService_GetActiveJobsForCompany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetActiveJobsForCompanyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).GetActiveJobsForCompany(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_GetActiveJobsForCompany_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).GetActiveJobsForCompany(ctx, req.(*GetActiveJobsForCompanyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_GetActiveJobsForContractor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetActiveJobsForContractorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).GetActiveJobsForContractor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_GetActiveJobsForContractor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).GetActiveJobsForContractor(ctx, req.(*GetActiveJobsForContractorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_GetJobsWithRateAbove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetJobsWithRateAboveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).GetJobsWithRateAbove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_GetJobsWithRateAbove_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).GetJobsWithRateAbove(ctx, req.(*GetJobsWithRateAboveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_UpdateStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateJobStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).UpdateStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_UpdateStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).UpdateStatus(ctx, req.(*UpdateJobStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_UpdateRate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateJobRateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).UpdateRate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_UpdateRate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).UpdateRate(ctx, req.(*UpdateJobRateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// JobService_ServiceDesc is the grpc.ServiceDesc for JobService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var JobService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "com.mercor.scd.grpc.JobService",
	HandlerType: (*JobServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetActiveJobsForCompany",
			Handler:    _JobService_GetActiveJobsForCompany_Handler,
		},
		{
			MethodName: "GetActiveJobsForContractor",
			Handler:    _JobService_GetActiveJobsForContractor_Handler,
		},
		{
			MethodName: "GetJobsWithRateAbove",
			Handler:    _JobService_GetJobsWithRateAbove_Handler,
		},
		{
			MethodName: "UpdateStatus",
			Handler:    _JobService_UpdateStatus_Handler,
		},
		{
			MethodName: "UpdateRate",
			Handler:    _JobService_UpdateRate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "scd_service.proto",
}

const (
	TimelogService_GetTimelogsForJob_FullMethodName            = "/com.mercor.scd.grpc.TimelogService/GetTimelogsForJob"
	TimelogService_GetTimelogsForContractor_FullMethodName     = "/com.mercor.scd.grpc.TimelogService/GetTimelogsForContractor"
	TimelogService_GetTimelogsWithDurationAbove_FullMethodName = "/com.mercor.scd.grpc.TimelogService/GetTimelogsWithDurationAbove"
	TimelogService_AdjustTimelog_FullMethodName                = "/com.mercor.scd.grpc.TimelogService/AdjustTimelog"
)

// TimelogServiceClient is the client API for TimelogService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TimelogServiceClient interface {
	GetTimelogsForJob(ctx context.Context, in *GetTimelogsForJobRequest, opts ...grpc.CallOption) (*TimelogListResponse, error)
	GetTimelogsForContractor(ctx context.Context, in *GetTimelogsForContractorRequest, opts ...grpc.CallOption) (*TimelogListResponse, error)
	GetTimelogsWithDurationAbove(ctx context.Context, in *GetTimelogsWithDurationAboveRequest, opts ...grpc.CallOption) (*TimelogListResponse, error)
	AdjustTimelog(ctx context.Context, in *AdjustTimelogRequest, opts ...grpc.CallOption) (*TimelogResponse, error)
}

type timelogServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTimelogServiceClient(cc grpc.ClientConnInterface) TimelogServiceClient {
	return &timelogServiceClient{cc}
}

func (c *timelogServiceClient) GetTimelogsForJob(ctx context.Context, in *GetTimelogsForJobRequest, opts ...grpc.CallOption) (*TimelogListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TimelogListResponse)
	err := c.cc.Invoke(ctx, TimelogService_GetTimelogsForJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timelogServiceClient) GetTimelogsForContractor(ctx context.Context, in *GetTimelogsForContractorRequest, opts ...grpc.CallOption) (*TimelogListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TimelogListResponse)
	err := c.cc.Invoke(ctx, TimelogService_GetTimelogsForContractor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timelogServiceClient) GetTimelogsWithDurationAbove(ctx context.Context, in *GetTimelogsWithDurationAboveRequest, opts ...grpc.CallOption) (*TimelogListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TimelogListResponse)
	err := c.cc.Invoke(ctx, TimelogService_GetTimelogsWithDurationAbove_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timelogServiceClient) AdjustTimelog(ctx context.Context, in *AdjustTimelogRequest, opts ...grpc.CallOption) (*TimelogResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TimelogResponse)
	err := c.cc.Invoke(ctx, TimelogService_AdjustTimelog_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TimelogServiceServer is the server API for TimelogService service.
// All implementations must embed UnimplementedTimelogServiceServer
// for forward compatibility.
type TimelogServiceServer interface {
	GetTimelogsForJob(context.Context, *GetTimelogsForJobRequest) (*TimelogListResponse, error)
	GetTimelogsForContractor(context.Context, *GetTimelogsForContractorRequest) (*TimelogListResponse, error)
	GetTimelogsWithDurationAbove(context.Context, *GetTimelogsWithDurationAboveRequest) (*TimelogListResponse, error)
	AdjustTimelog(context.Context, *AdjustTimelogRequest) (*TimelogResponse, error)
	mustEmbedUnimplementedTimelogServiceServer()
}

// UnimplementedTimelogServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTimelogServiceServer struct{}

func (UnimplementedTimelogServiceServer) GetTimelogsForJob(context.Context, *GetTimelogsForJobRequest) (*TimelogListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTimelogsForJob not implemented")
}
func (UnimplementedTimelogServiceServer) GetTimelogsForContractor(context.Context, *GetTimelogsForContractorRequest) (*TimelogListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTimelogsForContractor not implemented")
}
func (UnimplementedTimelogServiceServer) GetTimelogsWithDurationAbove(context.Context, *GetTimelogsWithDurationAboveRequest) (*TimelogListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTimelogsWithDurationAbove not implemented")
}
func (UnimplementedTimelogServiceServer) AdjustTimelog(context.Context, *AdjustTimelogRequest) (*TimelogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AdjustTimelog not implemented")
}
func (UnimplementedTimelogServiceServer) mustEmbedUnimplementedTimelogServiceServer() {}
func (UnimplementedTimelogServiceServer) testEmbeddedByValue()                        {}

// UnsafeTimelogServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TimelogServiceServer will
// result in compilation errors.
type UnsafeTimelogServiceServer interface {
	mustEmbedUnimplementedTimelogServiceServer()
}

func RegisterTimelogServiceServer(s grpc.ServiceRegistrar, srv TimelogServiceServer) {
	// If the following call pancis, it indicates UnimplementedTimelogServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TimelogService_ServiceDesc, srv)
}

func _TimelogService_GetTimelogsForJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTimelogsForJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimelogServiceServer).GetTimelogsForJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimelogService_GetTimelogsForJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimelogServiceServer).GetTimelogsForJob(ctx, req.(*GetTimelogsForJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimelogService_GetTimelogsForContractor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTimelogsForContractorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimelogServiceServer).GetTimelogsForContractor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimelogService_GetTimelogsForContractor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimelogServiceServer).GetTimelogsForContractor(ctx, req.(*GetTimelogsForContractorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimelogService_GetTimelogsWithDurationAbove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTimelogsWithDurationAboveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimelogServiceServer).GetTimelogsWithDurationAbove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimelogService_GetTimelogsWithDurationAbove_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimelogServiceServer).GetTimelogsWithDurationAbove(ctx, req.(*GetTimelogsWithDurationAboveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimelogService_AdjustTimelog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AdjustTimelogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimelogServiceServer).AdjustTimelog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimelogService_AdjustTimelog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimelogServiceServer).AdjustTimelog(ctx, req.(*AdjustTimelogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TimelogService_ServiceDesc is the grpc.ServiceDesc for TimelogService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TimelogService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "com.mercor.scd.grpc.TimelogService",
	HandlerType: (*TimelogServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTimelogsForJob",
			Handler:    _TimelogService_GetTimelogsForJob_Handler,
		},
		{
			MethodName: "GetTimelogsForContractor",
			Handler:    _TimelogService_GetTimelogsForContractor_Handler,
		},
		{
			MethodName: "GetTimelogsWithDurationAbove",
			Handler:    _TimelogService_GetTimelogsWithDurationAbove_Handler,
		},
		{
			MethodName: "AdjustTimelog",
			Handler:    _TimelogService_AdjustTimelog_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "scd_service.proto",
}

const (
	PaymentLineItemService_GetPaymentLineItemsForJob_FullMethodName        = "/com.mercor.scd.grpc.PaymentLineItemService/GetPaymentLineItemsForJob"
	PaymentLineItemService_GetPaymentLineItemsForTimelog_FullMethodName    = "/com.mercor.scd.grpc.PaymentLineItemService/GetPaymentLineItemsForTimelog"
	PaymentLineItemService_GetPaymentLineItemsForContractor_FullMethodName = "/com.mercor.scd.grpc.PaymentLineItemService/GetPaymentLineItemsForContractor"
	PaymentLineItemService_MarkAsPaid_FullMethodName                       = "/com.mercor.scd.grpc.PaymentLineItemService/MarkAsPaid"
	PaymentLineItemService_GetTotalAmountForContractor_FullMethodName      = "/com.mercor.scd.grpc.PaymentLineItemService/GetTotalAmountForContractor"
)

// PaymentLineItemServiceClient is the client API for PaymentLineItemService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PaymentLineItemServiceClient interface {
	GetPaymentLineItemsForJob(ctx context.Context, in *GetPaymentLineItemsForJobRequest, opts ...grpc.CallOption) (*PaymentLineItemListResponse, error)
	GetPaymentLineItemsForTimelog(ctx context.Context, in *GetPaymentLineItemsForTimelogRequest, opts ...grpc.CallOption) (*PaymentLineItemListResponse, error)
	GetPaymentLineItemsForContractor(ctx context.Context, in *GetPaymentLineItemsForContractorRequest, opts ...grpc.CallOption) (*PaymentLineItemListResponse, error)
	MarkAsPaid(ctx context.Context, in *MarkAsPaidRequest, opts ...grpc.CallOption) (*PaymentLineItemResponse, error)
	GetTotalAmountForContractor(ctx context.Context, in *GetTotalAmountForContractorRequest, opts ...grpc.CallOption) (*TotalAmountResponse, error)
}

type paymentLineItemServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPaymentLineItemServiceClient(cc grpc.ClientConnInterface) PaymentLineItemServiceClient {
	return &paymentLineItemServiceClient{cc}
}

func (c *paymentLineItemServiceClient) GetPaymentLineItemsForJob(ctx context.Context, in *GetPaymentLineItemsForJobRequest, opts ...grpc.CallOption) (*PaymentLineItemListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PaymentLineItemListResponse)
	err := c.cc.Invoke(ctx, PaymentLineItemService_GetPaymentLineItemsForJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentLineItemServiceClient) GetPaymentLineItemsForTimelog(ctx context.Context, in *GetPaymentLineItemsForTimelogRequest, opts ...grpc.CallOption) (*PaymentLineItemListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PaymentLineItemListResponse)
	err := c.cc.Invoke(ctx, PaymentLineItemService_GetPaymentLineItemsForTimelog_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentLineItemServiceClient) GetPaymentLineItemsForContractor(ctx context.Context, in *GetPaymentLineItemsForContractorRequest, opts ...grpc.CallOption) (*PaymentLineItemListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PaymentLineItemListResponse)
	err := c.cc.Invoke(ctx, PaymentLineItemService_GetPaymentLineItemsForContractor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentLineItemServiceClient) MarkAsPaid(ctx context.Context, in *MarkAsPaidRequest, opts ...grpc.CallOption) (*PaymentLineItemResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PaymentLineItemResponse)
	err := c.cc.Invoke(ctx, PaymentLineItemService_MarkAsPaid_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentLineItemServiceClient) GetTotalAmountForContractor(ctx context.Context, in *GetTotalAmountForContractorRequest, opts ...grpc.CallOption) (*TotalAmountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TotalAmountResponse)
	err := c.cc.Invoke(ctx, PaymentLineItemService_GetTotalAmountForContractor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PaymentLineItemServiceServer is the server API for PaymentLineItemService service.
// All implementations must embed UnimplementedPaymentLineItemServiceServer
// for forward compatibility.
type PaymentLineItemServiceServer interface {
	GetPaymentLineItemsForJob(context.Context, *GetPaymentLineItemsForJobRequest) (*PaymentLineItemListResponse, error)
	GetPaymentLineItemsForTimelog(context.Context, *GetPaymentLineItemsForTimelogRequest) (*PaymentLineItemListResponse, error)
	GetPaymentLineItemsForContractor(context.Context, *GetPaymentLineItemsForContractorRequest) (*PaymentLineItemListResponse, error)
	MarkAsPaid(context.Context, *MarkAsPaidRequest) (*PaymentLineItemResponse, error)
	GetTotalAmountForContractor(context.Context, *GetTotalAmountForContractorRequest) (*TotalAmountResponse, error)
	mustEmbedUnimplementedPaymentLineItemServiceServer()
}

// UnimplementedPaymentLineItemServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPaymentLineItemServiceServer struct{}

func (UnimplementedPaymentLineItemServiceServer) GetPaymentLineItemsForJob(context.Context, *GetPaymentLineItemsForJobRequest) (*PaymentLineItemListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPaymentLineItemsForJob not implemented")
}
func (UnimplementedPaymentLineItemServiceServer) GetPaymentLineItemsForTimelog(context.Context, *GetPaymentLineItemsForTimelogRequest) (*PaymentLineItemListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPaymentLineItemsForTimelog not implemented")
}
func (UnimplementedPaymentLineItemServiceServer) GetPaymentLineItemsForContractor(context.Context, *GetPaymentLineItemsForContractorRequest) (*PaymentLineItemListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPaymentLineItemsForContractor not implemented")
}
func (UnimplementedPaymentLineItemServiceServer) MarkAsPaid(context.Context, *MarkAsPaidRequest) (*PaymentLineItemResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkAsPaid not implemented")
}
func (UnimplementedPaymentLineItemServiceServer) GetTotalAmountForContractor(context.Context, *GetTotalAmountForContractorRequest) (*TotalAmountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTotalAmountForContractor not implemented")
}
func (UnimplementedPaymentLineItemServiceServer) mustEmbedUnimplementedPaymentLineItemServiceServer() {
}
func (UnimplementedPaymentLineItemServiceServer) testEmbeddedByValue() {}

// UnsafePaymentLineItemServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PaymentLineItemServiceServer will
// result in compilation errors.
type UnsafePaymentLineItemServiceServer interface {
	mustEmbedUnimplementedPaymentLineItemServiceServer()
}

func RegisterPaymentLineItemServiceServer(s grpc.ServiceRegistrar, srv PaymentLineItemServiceServer) {
	// If the following call pancis, it indicates UnimplementedPaymentLineItemServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PaymentLineItemService_ServiceDesc, srv)
}

func _PaymentLineItemService_GetPaymentLineItemsForJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPaymentLineItemsForJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentLineItemServiceServer).GetPaymentLineItemsForJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentLineItemService_GetPaymentLineItemsForJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentLineItemServiceServer).GetPaymentLineItemsForJob(ctx, req.(*GetPaymentLineItemsForJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentLineItemService_GetPaymentLineItemsForTimelog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPaymentLineItemsForTimelogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentLineItemServiceServer).GetPaymentLineItemsForTimelog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentLineItemService_GetPaymentLineItemsForTimelog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentLineItemServiceServer).GetPaymentLineItemsForTimelog(ctx, req.(*GetPaymentLineItemsForTimelogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentLineItemService_GetPaymentLineItemsForContractor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPaymentLineItemsForContractorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentLineItemServiceServer).GetPaymentLineItemsForContractor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentLineItemService_GetPaymentLineItemsForContractor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentLineItemServiceServer).GetPaymentLineItemsForContractor(ctx, req.(*GetPaymentLineItemsForContractorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentLineItemService_MarkAsPaid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkAsPaidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentLineItemServiceServer).MarkAsPaid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentLineItemService_MarkAsPaid_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentLineItemServiceServer).MarkAsPaid(ctx, req.(*MarkAsPaidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentLineItemService_GetTotalAmountForContractor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTotalAmountForContractorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentLineItemServiceServer).GetTotalAmountForContractor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentLineItemService_GetTotalAmountForContractor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentLineItemServiceServer).GetTotalAmountForContractor(ctx, req.(*GetTotalAmountForContractorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PaymentLineItemService_ServiceDesc is the grpc.ServiceDesc for PaymentLineItemService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PaymentLineItemService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "com.mercor.scd.grpc.PaymentLineItemService",
	HandlerType: (*PaymentLineItemServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPaymentLineItemsForJob",
			Handler:    _PaymentLineItemService_GetPaymentLineItemsForJob_Handler,
		},
		{
			MethodName: "GetPaymentLineItemsForTimelog",
			Handler:    _PaymentLineItemService_GetPaymentLineItemsForTimelog_Handler,
		},
		{
			MethodName: "GetPaymentLineItemsForContractor",
			Handler:    _PaymentLineItemService_GetPaymentLineItemsForContractor_Handler,
		},
		{
			MethodName: "MarkAsPaid",
			Handler:    _PaymentLineItemService_MarkAsPaid_Handler,
		},
		{
			MethodName: "GetTotalAmountForContractor",
			Handler:    _PaymentLineItemService_GetTotalAmountForContractor_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "scd_service.proto",
}
